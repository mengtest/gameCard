// ------------------------------------------------------------------------------
//  <autogenerated>
//      This code was generated by a tool.
//      Mono Runtime Version: 4.0.30319.1
// 
//      Changes to this file may cause incorrect behavior and will be lost if 
//      the code is regenerated.
//  </autogenerated>
// ------------------------------------------------------------------------------
using System;
using UnityEngine;
using Pomelo.DotNetClient;
using SimpleJson;
using System.Collections.Generic;
using System.IO;
using ComponentAce.Compression.Libs.zlib;


//using System.Timers;
#if NETFX_CORE
using MarkerMetro.Unity.WinLegacy.Timers;
#else
using System.Timers;
#endif
using DataModel;

public class Network
{

    static public string SERVER_IP = "";
    static public int SERVER_PORT = 0;

    #region Instance
    /// <summary>
    /// 禁用创建。
    /// </summary>
    private Network()//not allow create.
    {
#if UNITY_STANDALONE
       
        UnityEngine.Security.PrefetchSocketPolicy(SERVER_IP, 7935);
#endif
        m_connectFail.Add("ret", ResponseCode.ConnectFail);
    }

    public void initAuthServerWithLua(SLua.LuaFunction onInited)
    {
        initAuthServer(() =>
        {
            onInited.call();
        });
    }
    public void initAuthServer(Action onInited)
    {
		MyDebug.Log("SERVER_IP " + SERVER_IP);
        updateServer(m_PlatformServer, SERVER_IP, SERVER_PORT, false);
        if (onInited != null)
            onInited();
    }

    /// <summary>
    /// 单例对象。
    /// </summary>
    public static Network Instance
    {
        get
        {
            if (_instance == null)
            {
                _instance = new Network();
            }
            return _instance;
        }
    }

    public static void Destroy()
    {
        if (_instance != null)
        {
            List<string> keys = new List<string>(_instance.m_serverConfig.Keys);
            int i = 0;
            for (i = 0; i < keys.Count; i++)
            {
                _instance.m_serverConfig[keys[i]] = null;
            }
            _instance.m_serverConfig.Clear();
            keys = new List<string>(_instance.m_clients.Keys);
            for (i = 0; i < keys.Count; i++)
            {
                var pomelo = _instance.m_clients[keys[i]];
                if (pomelo != null)
                {
                    pomelo.disconnect();
                }
                _instance.m_clients[keys[i]] = null;
            }

            _instance.m_clients.Clear();
            _instance.onCallbackForDataEye = null;
            _instance.onNetworkConnected = null;
            _instance.onNetworkSlow = null;
            _instance.onNetworkFast = null;
            _instance.onNetworkSuccess = null;
            _instance.onNetworkError = null;
            _instance.onNetworkReconnet = null;
            _instance = null;
        }
    }
    private static Network _instance = null;

    #endregion

    #region events
    /// <summary>
    /// 每当请求后200毫秒内没有服务器返回则触发，表示暂时没有返回，如果多个请求同时发生，有可能连续发起此事件，可以在这里监听弹出网络等待菊花，外部需要验证是否已打开，不要重复打开。
    /// trigger while 200ms later by every request, need show dialog,need check dialog is opened
    /// </summary>
    public networkSlowEventHandler onNetworkSlow;
    public delegate void networkSlowEventHandler();

    /// <summary>
    /// 当连接、重新连接，请求返回后触发，可以关闭等待的菊花，需要处理好和timeout的dialog的交互。
    /// trigger while connect,reconnect,request response,can close dialog.
    /// </summary>
    public networkFastEventHandler onNetworkFast;
    public delegate void networkFastEventHandler();

    /// <summary>
    /// 当连接、重新连接，请求返回后触发，可以关闭等待的菊花，需要处理好和timeout的dialog的交互。
    /// trigger while connect,reconnect,request response,can close dialog.
    /// </summary>
    public networkReconnetEventHandler onNetworkReconnet;
    public delegate void networkReconnetEventHandler();

    /// <summary>
    /// 网络请求，成功反回了数据，无异常。
    /// </summary>
    public networkSuccessEventHandler onNetworkSuccess;
    public delegate void networkSuccessEventHandler(string api);

    /// <summary>
    /// 当发生网络出错时触发，例如网络返回的数据格式不正确，可能是超时断开网络，可能是逻辑错误，对timeout必须处理。其他逻辑错误可考虑弹出错误提示对话框
    /// 第2，3个参数可能为null，第三个参数是请求时传递的参数。
    /// </summary>
    public networkErrorEventHandler onNetworkError;
    public delegate void networkErrorEventHandler(int nRet, JsonObject oResult, object callbackArgs);

    /// <summary>
    /// 数据收集。。
    /// </summary>
    public Action<string, JsonObject> onCallbackForDataEye;
    /// <summary>
    /// 当发生网络connect successful .
    /// 
    /// </summary>
    public Action<string> onNetworkConnected;

    #endregion

    #region serverInfos
    /// <summary>
    /// The m_ auth server.
    /// </summary>
    private string m_AuthServer = "auth";

    /// <summary>
    /// 对应逻辑服务端的服务器。
    /// </summary>
    private string m_LogicServer = "logic";

    /// <summary>
    /// 对应登录服务端的服务器。
    /// </summary>
    private string m_PlatformServer = "platform";

    /// <summary>
    /// 从gate下发的，分配服务器地址的json.
    /// 格式：{"logic":{host:"127.0.0.1",port:3012,useSession:true},"chat":{host:"127.0.0.1",port:3013,useSession:false}}
    /// 
    /// </summary>
    private Dictionary<string, JsonObject> m_serverConfig = new Dictionary<string, JsonObject>();

    /// <summary>
    /// session管理，
    /// 由于手机长连接很容易断，所以重连后，
    /// 根据session判断是否需要执行重新登录（比较耗流量的一个操作），
    /// 还是可以继续操作，不执行登录操作
    /// 服务器重启，服务器用户缓存被清理时，session重置。
    /// </summary>
    private Dictionary<string, string> m_sessions = new Dictionary<string, string>();

    /// <summary>
    /// 时间管理管理，服务端和客户端时间修正。
    /// </summary>
    private Dictionary<string, long> m_deviationTimes = new Dictionary<string, long>();

    /// <summary>
    /// 根据不同类型连接不同的服务器，统一管理。
    /// </summary>
    private Dictionary<string, PomeloClient> m_clients = new Dictionary<string, PomeloClient>();

    ///<summary>
    /// 根据不同类型连接的线程（只在连接过程中创建）
    ///</summary>
    //private Dictionary<string, Thread> m_clientThreads = new Dictionary<string, Thread>();

    /// <summary>
    /// 请求后多久算是网络慢，需要出菊花？
    /// </summary>
    private int m_slowTime = 400;//400ms,后续改进为从配置文件读取

    /// <summary>
    /// 请求后多久算是网络卡了，需要提示重新连接。
    /// </summary>
    private int m_timeoutTime = 30000;//20s

    /// <summary>
    /// 每次网络请求完的0.5秒，理论上还在播放特效，不可能再触发事件。
    /// </summary>
    private int m_workDelayTime = 1000;

    #endregion



    #region tools:createTimer,josnWithKV, buildCallback
    
    private void callbackInMainThread(Action action)
    {
        SLua.LuaTimer.add(0, (id) =>
        {
            try
            {
                action();
            }
            catch (Exception ex)
            {
                MyDebug.LogError(ex.ToString());
            }
        });
    }
    /// <summary>
    /// 创建timer，
    /// </summary>
    /// <param name="nInterval">毫秒数</param>
    /// <param name="fCallback"></param>
    /// <returns>Timer</returns>
    private Timer createTimer(int nInterval, Action fCallback)
    {
        Timer timer = new Timer(nInterval);
        timer.AutoReset = false;

        timer.Elapsed += new ElapsedEventHandler((o, e) =>
        {
            callbackInMainThread(fCallback);
        });
        timer.Enabled = true;
        return timer;
    }

    /// <summary>
    /// 提供一个方便的一行式代码构建JsonObject对象。仿造obj-c的字典构造方式。
    /// 奇数位必须为字符串，偶数位可以是string或int。
    /// ex. jsonWithKV("name", sName, "sex", nSex)
    /// </summary>
    /// <param name="args">key1,value1,key2,value2</param>
    /// <returns>{key1:value1,key2:value2}</returns>
    public JsonObject jsonWithKV(params object[] args)
    {
        JsonObject jo = new JsonObject();
        for (int i = 0; i < args.Length; i += 2)
        {
            jo.Add(new KeyValuePair<string, object>(args[i] as string, args[i + 1]));
        }
        return jo;
    }

    /// <summary>
    /// 方便后面api增加时减少重复代码，同时把pomelo的传递方式更改为双回调机制，用于支持更方便的错误处理。
    /// 闭包封装了回调参数和错误处理。
    /// fErrorCallback采用可选参数方式实现，非必须，如果传入，类型是：Func<int,JsonObject,object,bool>即bool XXX(int a, JsonObject b,object c);
    /// </summary>
    /// <param name="callbackArgs"></param>
    /// <param name="fCallback"></param>
    /// <param name="fErrorCallback"></param>
    /// <returns></returns>
    public Action<JsonObject> buildCallback(object callbackArgs, Action<JsonObject, object> fCallback, Func<int, JsonObject, object, bool> fErrorCallback)
    {
        return (jo) =>
        {
            //隐藏loading
            if (!jo.ContainsKey("ret"))
            {//返回的格式错误。
                if ((fErrorCallback == null || !fErrorCallback(ResponseCode.FormatError, jo, callbackArgs)) && onNetworkError != null)
                    onNetworkError(ResponseCode.FormatError, jo, callbackArgs);
                return;
            }
            int nRet = jo.num("ret");
            if (nRet.ToString().Equals("0"))
            {
                //成功反馈。没有错误。
                if (jo.ContainsKey("update"))
                {
                    MPlayer2.Instance.update(jo.get<JsonObject>("update"));
                }
                fCallback(jo, callbackArgs);
            }
            else
            {
                if ((fErrorCallback == null || !fErrorCallback(nRet, jo, callbackArgs)) && onNetworkError != null)
                    onNetworkError(nRet, jo, callbackArgs);
            }
        };
    }
    #endregion



    #region connect session disconnect updateServer updatePlayer

    public long serverToClientTime(long serverTime, string whichServer = "logic")
    {
        if (m_deviationTimes.ContainsKey(whichServer))
        {
            return serverTime - m_deviationTimes[whichServer];
        }
        else
        {
            return serverTime;
        }
    }


    public void onUpdateServerTime(string serverType, long serverUtcTime, double networkDeviationTime)
    {

        DateTime serverTime = new DateTime(1970, 1, 1, 0, 0, 0, 0);
        serverTime = serverTime.AddMilliseconds(serverUtcTime);
        serverTime = serverTime.ToLocalTime();
        long deviationTime = (long)DateTime.Now.Subtract(serverTime).TotalMilliseconds;
        if (MyDebug.isDebug)
            MyDebug.Log("networkDeviationTime:" + networkDeviationTime.ToString());
        deviationTime += (long)(networkDeviationTime / 2);
        if (MyDebug.isDebug)
            MyDebug.Log("Server Time Update, deviationTime:" + deviationTime.ToString());
        if (m_deviationTimes.ContainsKey(serverType))
        {
            m_deviationTimes[serverType] = deviationTime;
        }
        else
        {
            m_deviationTimes.Add(serverType, deviationTime);
        }
        //下面是utc处理。。现在服务器都是用的utc+8时间。客户端的utc不确定个
    }
    private void checkSession(string serverType, PomeloClient pc, Action<string> fCallback)
    {
        if (!m_serverConfig.ContainsKey(serverType))
        {
            fCallback(null);
            return;
        }

        JsonObject serverConfig = m_serverConfig[serverType];
        if (!serverConfig.ContainsKey("useSession"))
        {
            fCallback(null);
            return;
        }
        if ((bool)serverConfig["useSession"] == false)
        {
            fCallback(null);
            return;
        }

        string pid = PlayerPrefs.GetString("pid");
        string session = PlayerPrefs.GetString("skey");

        if (MyDebug.isDebug)
            MyDebug.Log("checkSession with session:" + session);
        DateTime startReq = DateTime.Now;
        if (serverType == m_LogicServer)
        {
            int tag = 1;
            if (CheckCount > 2)
            {
                tag = 0;
            }
            pc.request("logic.sessionHandler.checkSession", jsonWithKV("skey", session, "pid", pid, "tag", tag, "v", MPlayer2.Instance.getInt("Version")), (oResult) => //第三步，请求操作。
                {
                    CheckCount++;
                    TimeSpan span = DateTime.Now - startReq;
                    onUpdateServerTime(serverType, oResult.get<long>("serverTime"), span.TotalMilliseconds);
                    if (MyDebug.isDebug)
                        MyDebug.Log("checkSession return session:" + oResult.str("session"));
                    //					fCallback(oResult["session"] as string);
                    fCallback(oResult.str("ret"));
                });
        }
        else
        {
            fCallback("true");
        }
    }

    private void onRollingMsg(JsonObject oUpdate)
    {//combine player data
        if (MyDebug.isDebug)
            MyDebug.Log("onRollingMsg" + oUpdate.ToString());
    }
    private void onUpdateServer(JsonObject oServers)
    {
        foreach (string serverType in oServers.Keys)
        {
            updateServer(serverType, oServers[serverType] as JsonObject);
        }
    }
    public void updateServer(string serverType, string host, int port, bool useSession)
    {
        JsonObject jo = new JsonObject();
        jo.Add("host", host);
        jo.Add("port", port);
        jo.Add("useSession", useSession);
        updateServer(serverType, jo);
    }

    private void updateServer(string serverType, JsonObject serverInfo)
    {
        //serverInfo["host"] = m_realIp;
        //如果当前还不存在此服务器信息则加入。
        if (!m_serverConfig.ContainsKey(serverType))
        {
            m_serverConfig.Add(serverType, serverInfo);
            if (MyDebug.isDebug)
                MyDebug.Log("update " + serverType + " server with " + serverInfo.ToString());
            return;
        }
        JsonObject oldServerInfo = m_serverConfig[serverType];

        //判断是否和当前服务器信息一样
        //        if ((oldServerInfo["host"] as string) != (serverInfo["host"] as string) || oldServerInfo["port"] as string != serverInfo["port"] as string)
        //        {//干掉pomeloClient
        if (m_clients.ContainsKey(serverType))
        {
            m_clients[serverType].disconnect();
            m_clients[serverType] = null;
            m_clients.Remove(serverType);
        }
        if (m_sessions.ContainsKey(serverType))
        {
            m_sessions.Remove(serverType);
            //m_deviationTimes.Remove(serverType);
        }
        m_serverConfig[serverType] = serverInfo;
        if (MyDebug.isDebug)
            MyDebug.Log("update " + serverType + " server with " + serverInfo.ToString());
        //        }
    }
    private void onConnectServer(string serverType, PomeloClient pc)
    {
        //if (serverType == m_LogicServer)
        //    pomeloOn(pc, "onUpdatePlayer", onUpdatePlayer);
        if (m_server_events.ContainsKey(serverType))
        {
            var events = m_server_events[serverType];
            foreach (var msg in events.Keys)
            {
                registerToPomeloClient(pc, serverType, msg);
            }
        }

        pomeloOn(pc, "onUpdateServer", onUpdateServer);//all servers can update server 
        pomeloOn(pc, "rollingMessage", onRollingMsg);//all servers can update server 
        if (onNetworkConnected != null)
            onNetworkConnected(serverType);
    }

    private Dictionary<string, Dictionary<string, Action<string, JsonObject>>> m_server_events = new Dictionary<string, Dictionary<string, Action<string, JsonObject>>>();
    public void registerMsg(string serverType, string msg, Action<string, JsonObject> fnCallback)
    {
        if (!m_server_events.ContainsKey(serverType))
        {
            m_server_events.Add(serverType, new Dictionary<string, Action<string, JsonObject>>());
        }
        var events = m_server_events[serverType];
        if (!events.ContainsKey(msg))
        {
            events.Add(msg, fnCallback);
            if (m_clients.ContainsKey(serverType))
            {
                registerToPomeloClient(m_clients[serverType], serverType, msg);
            }
        }
        else
        {
            events[msg] = fnCallback;
        }
    }
    public void registerMsgByLua(string serverType, string msg, SLua.LuaFunction fnCallback)
    {
        registerMsg(serverType, msg, (msg1, data) =>
        {
            fnCallback.call(msg1, data);
        });
    }
    private void registerToPomeloClient(PomeloClient pc, string serverType, string msg)
    {
        pomeloOn(pc, msg, (JsonObject data) =>
        {
            onMsg(serverType, msg, data);
        });
    }

    private void onMsg(string serverType, string msg, JsonObject jo)
    {
        if (MyDebug.isDebug)
            MyDebug.Log("server:" + serverType + " msg:" + msg + " data:" + jo.ToString());
        if (!m_server_events.ContainsKey(serverType))
        {
            return;
        }
        var events = m_server_events[serverType];
        if (!events.ContainsKey(msg))
        {
            return;
        }

        uncompressMessage(ref jo);

        try
        {
            events[msg](msg, jo);
        }
        catch (Exception e)
        {
        }
    }

    private bool pomeloConnect(PomeloClient pc, Action action)
    {
        return pc.connect(null, (data) =>
        {
            callbackInMainThread(action);
        });

    }
    private void pomeloOn(PomeloClient pc, string eventName, Action<JsonObject> action)
    {
        pc.on(eventName, (data) =>
        {
            callbackInMainThread(() =>
            {
                action(data);
            });
        });
    }
    private void pomeloRequest(PomeloClient pc, string route, JsonObject msg, Action<JsonObject> action)
    {
        pc.request(route, msg, (data) =>
        {
            callbackInMainThread(() =>
            {
                action(data);
            });
        });
    }

    ///<summary>
    /// 去掉正在连接的线程
    ///</summary>
    private void RemoveConnThread(string server)
    {
        //if (m_clientThreads.ContainsKey(server))
        //{
        //    m_clientThreads[server].Abort();
        //    m_clientThreads[server] = null;
        //    m_clientThreads.Remove(server);
        //}
    }

    /// <summary>
    /// 创建PomeloClient对象，连接服务器。checkSession
    /// </summary>
    /// <param name="host"></param>
    /// <param name="port"></param>
    /// <param name="serverType"></param>
    /// <param name="fCallback"></param>
    private void connectServer(string host, int port, string serverType, Action<PomeloClient> fCallback, int retryConnectTimes = 3)
    {
		MyDebug.Log ("11111111111111111111111111111111");
        if (MyDebug.isDebug)
            MyDebug.Log("serali connect " + serverType + " server " + host + ":" + port.ToString());
        RemoveConnThread(serverType);
        PomeloClient pc = null;
        if (MyDebug.isDebug)
            MyDebug.Log("connectServer callback.");
		StartSingleThread(() =>
        {
            pc = new PomeloClient(host, port);

            pc.on(PomeloClient.EVENT_DISCONNECT, (jo) =>
            {
                //把自己干掉
                if (m_clients.ContainsKey(serverType))
                {
                    m_clients[serverType] = null;
                    m_clients.Remove(serverType);
                }
            });
            bool bOk = pomeloConnect(pc, () =>
            {
                //把自己加入,防止重入,连接失败会触发超时
                if (!m_clients.ContainsKey(serverType))
                {
                    onConnectServer(serverType, pc);
                    checkSession(serverType, pc, (session) =>
                    {
                        if (!m_clients.ContainsKey(serverType))
                        {
                            m_clients.Add(serverType, pc);//check complete then add to 
                            if (m_sessions.ContainsKey(serverType))
                            {
                                m_sessions[serverType] = session;
                            }
                            else
                            {
                                m_sessions.Add(serverType, session);
                            }
                            //onConnectServer(serverType, pc);
                        }
                        else
                        {
                            pc.disconnect();
                        }
                        //添加代码修正一直连接platform server的bug
                        if (serverType == m_LogicServer)
                        {
                            if (m_clients.ContainsKey(m_PlatformServer))
                            {
                                m_clients[m_PlatformServer].disconnect();
                                m_clients.Remove(m_PlatformServer);
                                RemoveConnThread(m_PlatformServer);
                            }
                        }
                        tryConnectServer(serverType, fCallback);
						MyDebug.Log("serali network over");
                    });

                }
                else
                {
                    pc.disconnect();
                    tryConnectServer(serverType, fCallback);
                }
            });
            if (!bOk)
            {
                //连接失败以后，重联四次，间隔时间加长
                if (retryConnectTimes > 0)
                {
                    Timer retryTimer = null;
                    retryTimer = createTimer(7000 - retryConnectTimes * 2000, () =>
                    {
                        connectServer(host, port, serverType, fCallback, retryConnectTimes - 1);
                    });
                }
                else
                {
                    fCallback(null);
                }
                
            }

        });
        //m_clientThreads.Add(serverType, connThread);
        //connThread.Start();
    }

    /// <summary>
    /// 线程执行 TODO
    /// </summary>
    /// <param name="p"></param>
    private void StartSingleThread(Action p)
    {
        //TODO
        p.Invoke();
    }

    /// <summary>
    /// 连接服务器,实现gate->logic，已连接则不重复连接，未连接则尝试连接。
    /// </summary>
    /// <param name="fCallback"></param>
    private void tryConnectServer(string server, Action<PomeloClient> fCallback)
    {
        if (m_clients.ContainsKey(server))
        {
            fCallback(m_clients[server]);//如果存在表示已连接。一般情况最优先执行这里。
        }
        else if (m_serverConfig.ContainsKey(server))
        {
            JsonObject serverConfig = m_serverConfig[server] as JsonObject;
            //connectServer(serverConfig["host"] as string, serverConfig.num("port"), server, fCallback);
			//update by lihui 2017-2-25
			#if UNITY_IPHONE 
			if (serverConfig ["domain"] != null) {
				MyDebug.Log ("serali network.cs domain");
				connectServer (serverConfig ["domain"] as string, serverConfig.num ("port"), server, fCallback);
			} else {
				MyDebug.Log ("serali network.cs host");
				connectServer(serverConfig["host"] as string, serverConfig.num("port"), server, fCallback);
			}
			#else
				connectServer(serverConfig["host"] as string, serverConfig.num("port"), server, fCallback);
			#endif
        }
        else
        {
            if (onNetworkError != null)
                onNetworkError(ResponseCode.ServerTypeError, null, server);
        }
    }

    private void disconnect(string serverType)
    {
        if (m_clients.ContainsKey(serverType))
        {
            m_clients[serverType].disconnect();
            m_clients.Remove(serverType);
        }
    }

    public void disconnectAll()
    {
        List<string> keys = new List<string>(m_clients.Keys);
        foreach (var key in keys)
        {
            if (m_clients.ContainsKey(key))
            {
                m_clients[key].disconnect();
                m_clients[key] = null;
            }
        }
        m_clients.Clear();
    }
    #endregion

    #region request

    private Dictionary<string, bool> m_working = new Dictionary<string, bool>();
    private bool checkWorking(string api)
    {
        if (m_working.ContainsKey(api))
        {
            return false;
        }
        m_working.Add(api, true);
        return true;
    }

    private void workComplete(string api, bool delayed = false)
    {
        if (m_working.ContainsKey(api))
        {
            if (delayed)
            {
                m_working.Remove(api);
            }
            else
            {
                createTimer(m_workDelayTime, () =>
                {
                    workComplete(api, true);
                });
            }
        }
    }

    private JsonObject m_connectFail = new JsonObject();
    private int CheckCount = 0;

    /// <summary>
    /// pomelo的调用入口，封装超时，重连，事件，连接服务器（gate->logic）。
    /// </summary>
    /// <param name="deamon">dont trigger onNetworkSlow,onNetworkFast</param>
    /// <param name="server">route,ex.logic,gate,chat</param>
    /// <param name="api"></param>
    /// <param name="args"></param>
    /// <param name="fCallback"></param>
    public void sendRequest(bool deamon, string server, string api, JsonObject args, Action<JsonObject> fCallback)
    {
        //if (RealIp == null)
        //{
        //    checkRealIP(() =>
        //    {
        //        sendRequest(deamon, server, api, args, fCallback);
        //    });
        //    return;
        //}
        if (!checkWorking(api))
        {
            return;
        }
        //Loom.checkInit();
        //显示loading
        //ApiLoading.show(10);
        Timer timeoutTimer = null;
        Timer slowTimer = null;
        bool bCompleted = false;
        if (!deamon)
        {
            slowTimer = createTimer(m_slowTime, () => //第一步建立timer，实现slow事件,和触发timeout。
            {
                if (bCompleted) return;
                if (onNetworkSlow != null)
                    onNetworkSlow();//慢网络回调
                timeoutTimer = createTimer(m_timeoutTime, () =>
                {
                    if (bCompleted) return;
                    if (MyDebug.isDebug)
                        MyDebug.Log("timeout with api:" + api);
                    //if (onNetworkError != null)
                    //    onNetworkError(ResponseCode.Timeout, null, server);

                    if (timeoutTimer != null)
                    {
                        timeoutTimer.Stop();
                        timeoutTimer.Close();
                        timeoutTimer = null;
                    }

                    RemoveConnThread(server);
                    if (onNetworkFast != null)
                    {
                        onNetworkFast.Invoke();
                    }

                    fCallback(m_connectFail);
                });

                if (slowTimer != null)
                {
                    slowTimer.Stop();
                    slowTimer.Close();
                    slowTimer = null;
                }

            });
        }
        else
        {
            timeoutTimer = createTimer(m_timeoutTime, () =>
            {
                if (bCompleted) return;
                if (MyDebug.isDebug)
                    MyDebug.Log("timeout with api:" + api);
                //if (onNetworkError != null)
                //    onNetworkError(ResponseCode.Timeout, null, server);
                if (timeoutTimer != null)
                {
                    timeoutTimer.Stop();
                    timeoutTimer.Close();

                    timeoutTimer = null;
                }

                RemoveConnThread(server);
                if (onNetworkFast != null)
                {
                    onNetworkFast.Invoke();
                }
                fCallback(m_connectFail);
            });
        }
        workComplete(api, true);
        tryConnectServer(server, (pc) => //第二步，连接服务器,实现gate->logic，已连接则不重复连接，未连接则尝试连接。
        {
            if (pc == null)
            {
                if (slowTimer != null)
                {
                    slowTimer.Stop();
                    slowTimer.Close();
                    slowTimer = null;
                }

                if (timeoutTimer != null)
                {
                    timeoutTimer.Stop();
                    timeoutTimer.Close();
                    timeoutTimer = null;
                }
                callbackInMainThread(() =>
                {
                    fCallback(m_connectFail);
                });
                RemoveConnThread(server);
                bCompleted = true;
                //fCallback(m_connectFail);

                return;
            }
            if (args == null)
            {
                args = jsonWithKV();
            }
            if (MyDebug.isDebug)
                MyDebug.Log("request:" + api + " with args:" + args.ToString());
            pomeloRequest(pc, api, args, (oResult) => //第三步，请求操作。
            {
                //清理timer，触发fastnetwork
                if (slowTimer != null)
                {
                    slowTimer.Stop();
                    slowTimer.Close();
                    slowTimer = null;
                }

                if (timeoutTimer != null)
                {
                    timeoutTimer.Stop();
                    timeoutTimer.Close();
                    timeoutTimer = null;
                }
                if (onNetworkFast != null) //第四步，回调fast事件。
                    onNetworkFast();
                if (onNetworkReconnet != null)
                {
                    onNetworkReconnet();
                }
                bCompleted = true;  

                uncompressMessage(ref oResult);
                fCallback(oResult);
                workComplete(api);
                //              FrameTimerManager.getInstance().add(1,1,()=>{
                //                  fCallback(oResult);
                //              });
                //Loom.QueueOnMainThread(()=>{
                //    fCallback(oResult);
                //});
            });
        });
    }    
    /////////////////////////////////////////////////////////
    /// function    : Network:unzipMsg 
    /// param       : string str 
    /// return      : SimpleJson.JsonObject 
    /// Comment     : 
    /////////////////////////////////////////////////////////
    JsonObject unzipMsg(string str)
    {
        byte[] buf = Convert.FromBase64String(str);

        MemoryStream os = new MemoryStream();

        ZOutputStream gzip = new ZOutputStream(os);

        gzip.Write(buf, 0, buf.Length);
        gzip.finish();

        byte[] dest = new byte[2048];

        gzip.Position = 0;
        int nReadSize;
        do
        {
            nReadSize = gzip.Read(dest, 0, dest.Length);

            os.Write(dest, 0, nReadSize);

        } while (nReadSize > 0);

        //dest = os.ToArray();
        //UnityEngine.Debug.Log("decompress:" + dest.Length);        

        str = System.Text.Encoding.UTF8.GetString(os.ToArray());
        os.Dispose();

        //if (MyDebug.isDebug)
        //    MyDebug.Log("RECV:" + str);
        return SimpleJson.SimpleJson.DeserializeObject(str) as JsonObject;
    }
    /////////////////////////////////////////////////////////
    /// function    : Network:uncompressMessage 
    /// param       : JsonObject msg 
    /// return      : bool 
    /// Comment     : 
    /////////////////////////////////////////////////////////
    bool uncompressMessage(ref JsonObject msg)
    {
        //if (MyDebug.isDebug)
        //    MyDebug.Log("RECV（source）:" + msg);

        if (msg.ContainsKey("zip"))
        {
            string str = msg.get<string>("zip");
            msg = unzipMsg(str);
        }        

        return true;
    }

    /// <summary>
    /// 提供一个方便lua访问
    /// </summary>
    /// <param name="args"></param>
    /// <returns>{key1:value1,key2:value2}</returns>
    private JsonObject jsonWithLuaTable(SLua.LuaTable args)
    {
        JsonObject jo = new JsonObject();
        foreach (var pair in args)
        {
            SLua.LuaTable luaTable = pair.value as SLua.LuaTable;
            if (luaTable != null)
            {
                var arr = jsonArrayWithLuaTable(luaTable);
                if (arr == null)
                {
                    jo.Add(new KeyValuePair<string, object>(pair.key as string, jsonWithLuaTable(luaTable)));
                }
                else
                {
                    jo.Add(new KeyValuePair<string, object>(pair.key as string, arr));
                }
            }
            else
            {
                jo.Add(new KeyValuePair<string, object>(pair.key as string, pair.value));
            }
        }
        return jo;
    }

    private JsonArray jsonArrayWithLuaTable(SLua.LuaTable luaTable)
    {
        JsonArray jo = new JsonArray();
        int i = 0;
        while (true)//lua从1开始
        {
            object obj = luaTable[i + 1];
            if (obj == null)
            {
                break;
            }
            else
            {
                SLua.LuaTable luaTable2 = obj as SLua.LuaTable;
                if (luaTable2 != null)
                {
                    var arr = jsonArrayWithLuaTable(luaTable2);
                    if (arr == null)
                    {
                        jo.Add(jsonWithLuaTable(luaTable2));
                    }
                    else
                    {
                        jo.Add(arr);
                    }
                }
                else
                {
                    jo.Add(obj);
                }
            }
            i++;
        }
        if (jo.Count == i)
        {
            return jo;
        }
        return null;
    }

    public void sendRequestWithLua(bool deamon, string server, string api, SLua.LuaTable args, SLua.LuaFunction fCallback, SLua.LuaFunction fErrorCallback)
    {
        sendRequestWithLua(deamon, server, api, args, fCallback, fErrorCallback, null);
    }
    /// <summary>
    /// 封装sendRequest,提供给lua访问
    /// </summary>
    /// <param name="deamon">dont trigger onNetworkSlow,onNetworkFast</param>
    /// <param name="server">route,ex.logic,gate,chat</param>
    /// <param name="api"></param>
    /// <param name="args"></param>
    /// <param name="fCallback"></param>
    public void sendRequestWithLua(bool deamon, string server, string api, SLua.LuaTable args, SLua.LuaFunction fCallback, SLua.LuaFunction fErrorCallback, SLua.LuaTable callbackArgs)
    {
        Action<JsonObject, object> fCallbackWrapper = delegate (JsonObject jo, object data)
        {
            try
            {
                fCallback.call(jo, data);
                if (onNetworkSuccess != null)
                {
                    onNetworkSuccess(api);
                }
                if (onCallbackForDataEye != null)
                {
                    onCallbackForDataEye(api, jo);
                }
                if (MyDebug.isDebug)
                {
                    MyDebug.Log(jo.ToString());
                }
            }
            catch (Exception e)
            {
                Debug.LogError(e.ToString());
            }

        };
        Func<int, JsonObject, object, bool> fErrorCallbackWrapper = null;
        if (fErrorCallback != null)
        {
            fErrorCallbackWrapper = delegate (int ret, JsonObject obj, object ob)
            {
                bool r = false;
                if (fErrorCallback != null)
                {
                    object o = fErrorCallback.call(ret, obj, ob);
                    if (o != null)
                    {
                        r = (bool)o;
                    }
                }
                return r;
            };
        }
        sendRequest(deamon, server, api, jsonWithLuaTable(args), buildCallback(callbackArgs, fCallbackWrapper, fErrorCallbackWrapper));
    }

    #endregion

    #region api
    public MRoot createDataModel(string data)
    {
        return MRoot.create(data);
    }
    #endregion
}
